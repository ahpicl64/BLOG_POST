# 동시성 문제 요소

## 배경
3D 모델링 기반 Try-on 서비스에서, 찾을수록 기술적인 구현 가능성, 타당성이 보이지않아 2D 기반으로 원복

## 현재 서비스에서 문제 발생 시나리오

1. 친구와 함께 고르기 시 고른 아이템이 동시 수정될 경우
2. 두 명 이상의 사용자에 의해 동시에 스토리(게시글)의 좋아요 수 혹은 메모(댓글)가 생길 경우

아래와 같이 **3단계**로 정리해볼게요.

1. **어떤 상황에서 동시성 문제가 발생하는가**
2. **어떤 기법(Concurrency Control)으로 어떤 문제를 해결할 수 있는가**
3. **실제 적용 가능한 기술·프레임워크 예시**

---

## 1. 동시성 문제 발생 시나리오

* **장바구니 동시 수정**

  * 친구와 함께 주문 기능: A와 B가 같은 카트에 동시에 아이템 추가/삭제 → 수량 불일치, 총합 계산 오류
* **좋아요·조회수 레이스**

  * 두 사용자가 거의 동시에 “좋아요” 요청 → 값이 하나만 증가하거나, +2가 누락
* **댓글 동시 작성·삭제**

  * 같은 게시물에 동시 댓글 작성 → 정렬·페이징 이상
  * 삭제와 조회가 겹칠 때 “삭제된 댓글이 보여짐” 등
* **주문 상태 업데이트**

  * 결제 승인/취소 요청이 꼬여서 상태 머신(state machine) 불일치

이런 “여러 클라이언트가 같은 리소스(레코드, 카운터, 상태)에 읽기·쓰기”를 할 때 **Race Condition**, **Lost Update**, **Dirty Read**, **Phantom Read** 같은 문제가 생깁니다.

---

## 2. 기법별 문제해결 접근

| 기법                                | 해결 대상 문제                   | 동작 방식 요약                                        |
| --------------------------------- | -------------------------- | ----------------------------------------------- |
| **1) 비관적 락 (Pessimistic Lock)**   | Lost Update, Dirty Read    | `SELECT … FOR UPDATE` 같은 DB 락으로 충돌 방지           |
| **2) 낙관적 동시성 제어 (OCC)**           | Lost Update                | 버전(version)/타임스탬프 체크 후 `UPDATE WHERE version=?` |
| **3) 분산 락 (Distributed Lock)**    | 서비스 간 자원 경합                | Redis·ZooKeeper 등에 락을 걸어, 획득 시에만 처리             |
| **4) 원자적 연산 (Atomic Ops)**        | 단순 카운터 증감 (좋아요, 조회수)       | `UPDATE counter SET v=v+1` 또는 `Redis INCR`      |
| **5) 이벤트 기반·CQRS/Event Sourcing** | 읽기·쓰기 분리, 최종 일관성(Eventual) | 쓰기→이벤트 발행→읽기용 DB 갱신 흐름으로 처리 지연 완화               |
| **6) 멱등성 처리 (Idempotency Key)**   | 중복 요청(네트워크 재시도) 방지         | 클라이언트가 고유 키 제공 → 중복 실행 무시                       |

> 각 기법은 “어떤 일관성 레벨”을 보장할지, “성능/확장성” 트레이드오프가 다릅니다.

---

## 3. 적용 가능한 기술·프레임워크 예시

### 1) RDB 기반 트랜잭션·락

* **Java/Spring**:

  * `@Transactional`, JPA `@Version`(낙관적), `LockModeType.PESSIMISTIC_WRITE`
  * MyBatis 매퍼에서 `SELECT … FOR UPDATE`
* **.NET/Entity Framework**:

  * `DbContext` 트랜잭션, `RowVersion` 컬럼

### 2) 분산 락

* **Redisson (Java)**: Redis 기반 `RLock` API, TTL 자동 갱신
* **Apache Curator (Java)**: ZooKeeper 위 추상화된 분산 락
* **etcd client**: Go/Python 바인딩으로 경량 분산 락

### 3) 메시지 큐·이벤트 스트리밍

* **Apache Kafka**: 고처리량 이벤트 발행/구독, 파티셔닝
* **RabbitMQ**: 토픽·라우팅 패턴 큐잉
* **AWS SQS/SNS**: 서버리스 연계

### 4) 이벤트 소싱·CQRS

* **Axon Framework (Java)**: 커맨드 핸들러, 이벤트 핸들러, 스냅샷
* **EventStoreDB**: 이벤트 저장 전용 DB

### 5) 원자 카운터·캐시

* **Redis**: `INCR`/`DECR`, PubSub
* **Hazelcast**: 인메모리 데이터 그리드

### 6) Actor 모델

* **Akka (JVM)**: 메시지 기반 비동기 액터, 상태 보존
* **Orleans (.NET)**: 분산 그레인(grain) 추상화

---

이렇게

1. **문제가 어디서 발생하는지**를 짚고,
2. **각 기법이 어떤 일관성·성능 이슈를 해결**하는지 이해한 뒤,
3. \*\*자신의 스택(Java·.NET·Node.js·Go 등)과 요구사항(CPS, 일관성 수준, 운영 복잡도)\*\*에 맞는 도구를 선택
   하면, 대규모 사용자 동시성에도 안정적인 서비스 운영이 가능합니다.
